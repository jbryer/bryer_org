{
  "hash": "7d704eb0d75c8fbef75dd7da86e1321e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Simulating Monty Hall's Problem\"\nauthor: \"Jason Bryer\"\ndate: 2025-10-01\ndraft: false\ndescription: \"Simulation of Monty Hall's problem\"\ncategories: [\"R\"]\nimage: \"Monty_open_door.svg.png\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n::: {.cell}\n\n:::\n\n\nI find that when teaching statistics (and probability) it is often helpful to simulate data first in order to get an understanding of the problem. The Monty Hall problem recently came up in a class so I implemented a function to play the game.\n\nThe Monty Hall problem results from a game show, [*Let's Make a Deal*](https://en.wikipedia.org/wiki/Let%27s_Make_a_Deal), hosted by Monty Hall. In this game, the player picks one of three doors. Behind one is a car, the other two are goats. After picking a door the player is shown the contents of one of the other two doors, which because the host knows the contents, is a goat. The question to the player: Do you switch your choice?\n\nFor more information, be sure to see the [Wikipedia article](https://en.wikipedia.org/wiki/Monty_Hall_problem).\n\nBelow we implement a function that will simulate a single play of this game. You can play interactively, or if you specify the `pick` and `switch` parameters this can be looped in order to simulate the results.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonty_hall <- function(pick, switch) {\n\tinteractive <- FALSE\n\tif(missing(pick)) {\n\t\tinteractive <- TRUE\n\t\tcat('Pick your door:')\n\t\tpick <- LETTERS[menu(c('A', 'B', 'C'))]\n\t} else {\n\t\tif(!pick %in% LETTERS[1:3]) {\n\t\t\tstop('pick must be either A, B, or C')\n\t\t}\n\t}\n\tdoors <- c('win', 'lose', 'lose')\n\tdoors <- sample(doors) # Shuffle the doors\n\tnames(doors) <- LETTERS[1:3]\n\tif(doors[pick] == 'win') {\n\t\tshow <- sample(names(doors[!names(doors) %in% pick]), size = 1)\n\t} else {\n\t\tshow <- doors[!names(doors) %in% pick] == 'lose'\n\t\tshow <- names(which(show == TRUE))\n\t}\n\tif(missing(switch)) {\n\t\tinteractive <- TRUE\n\t\tcat(paste0('Showing door ', show, '. Do you want to switch your choice?'))\n\t\tswitch <- menu(c('yes', 'no')) == 1\n\t}\n\tif(switch) {\n\t\tpick <- names(doors)[!names(doors) %in% c(show, pick)]\n\t}\n\twin <- unname(doors[pick] == 'win')\n\tif(interactive) {\n\t\tif(win) {\n\t\t\tcat('You win!')\n\t\t} else {\n\t\t\tcat('Sorry, you lost.')\n\t\t}\n\t\tinvisible(win)\n\t} else {\n\t\treturn(win)\n\t}\n}\n```\n:::\n\n\nWe can play a single game:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonty_hall()\n```\n:::\n\n\n```\nPick your door:\n1: A\n2: B\n3: C\n\nSelection: 2\nShowing door A. Do you want to switch your choice?\n1: yes\n2: no\n\nSelection: 1\nYou win!\n```\n\nLet's now simulate 1,000 games. We will use two vectors, `mh_switch` and `mh_no_switch`, to store the results after switching doors or not, respectively. For each iteration, the initial door pick is randomly selected.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_games <- 1000\nmh_switch <- logical(n_games)\nmh_no_switch <- logical(n_games)\nfor(i in 1:n_games) {\n\tpick <- sample(LETTERS[1:3], size = 1)\n\tmh_switch[i] <- monty_hall(pick = pick, switch = TRUE)\n\tmh_no_switch[i] <- monty_hall(pick = pick, switch = FALSE)\n}\n```\n:::\n\n\nThe probability of winning if we switch the door is:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(mh_switch)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.671\n```\n\n\n:::\n:::\n\n\nThe probability of winning if we do not switch the door is:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(mh_no_switch)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.328\n```\n\n\n:::\n:::\n\n\nIt should be noted that the theoretical probability of winning if you switch is 2/3, and is 1/3 if you don't switch.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
{
  "hash": "169be923629fea9b8650c99149696413",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"User parameters for Shiny applications\"\nauthor: \"Jason Bryer\"\ndate: 2025-05-16\ndraft: false\ndescription: \"\"\ncategories: [\"R\", \"Statistics\"]\nimage: \"2025-05-16-User_params_for_shiny.png\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n**tl;dr**\n\nOnce the `login` package is installed, you can run two demos using the following commands:\n\n* `shiny::runApp(paste0(find.package('login'), '/user_params/'))`  \n[https://github.com/jbryer/login/blob/main/inst/user_params/app.R](https://github.com/jbryer/login/blob/main/inst/user_params/app.R)\n\n* `shiny::runApp(paste0(find.package('login'), '/data_viewer/'))`  \n[https://github.com/jbryer/login/blob/main/inst/data_viewer/app.R](https://github.com/jbryer/login/blob/main/inst/data_viewer/app.R)\n\n*Note that this is cross posted with a vignette in the [`login`](https://github.com/jbryer/login) R package. For the most up-to-date version go here: [https://jbryer.github.io/login/articles/paramaters.html](https://jbryer.github.io/login/articles/paramaters.html) Comments can be directed to me on Mastodon at [@jbryer@vis.social](https://vis.social/@jbryer).*\n\n\n## Introduction\n\nShiny is an incredible tool for interactive data analysis. For the vast majority of Shiny applications I have developed I make a choice regarding the default state of the application, but provide plenty of options for the user to change and/or customize the analysis. However, there are situations where the application would be better if the user was required to input certain parameters. Conceptually I often think of Shiny applications as an interactive version of a function, a function with many parameters, some of which the user needs to define the default parameters. This vignette describes a Shiny module where a given set of parameters must be set before the user engages with the main Shiny application, and those settings can be optionally saved as cookies to be used across sessions. Even though this is the main motivation for this Shiny module, it can also be used as a framework for saving user preferences where saving state on the Shiny server is not possible (e.g. when deployed to [www.shinyapps.io](https://www.shinyapps.io)).\n\nThe user parameter module is part of the `login` R package. The goal is to present the user with a set of parameters in a modal dialog as the Shiny application loads. The primary interface is through the `userParamServer()` function that can be included in the server code. The following is a basic example.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparams <- userParamServer(\n\tid = 'example',\n\tparams = c('name', 'email'),\n\tparam_labels = c('Your Name:', 'Email Address:'),\n\tparam_types = c('character', 'character'),\n\tintro_message = 'This is an example application that asks the user for two parameters.'),\n\tvalidator = my_validator\n```\n:::\n\n\n\n\nLike all [Shiny modules](https://mastering-shiny.org/scaling-modules.html), the `id` parameter is a unique identifier connected the server logic to the UI components. The `params` parameter is a character vector for the names of the parameters users need to input. These are the only two required parameters. By default all the parameters will assume to be characters using the `shiny::textInput()` function. However, the module supports multiple input types including:\n\n* `date` - Date values\n* `integer` - Integer values\n* `numeric` - Numeric values\n* `file` - File uploads (note the value will be the path to where the file is uploaded)\n* `select` - Drop down selection. This type requires additional information vis-Ã -vis the `input_params` parameter discussed latter.\n\nThe above will present the user with a modal dialog immediately when the Shiny application starts up as depicted below.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](screenshot_params1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n\nThe values can then be retrieved from the `params` object, which is depicted in the figure below.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](screenshot_params2.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n\nThe `userParamServer()` function returns a `shiny::reactiveValues()` object. As a result, any code that uses these values should automatically be updated if the values change.\n\nThere are two UI components, specifically the `showParamButton()` and `clearParamButton()` buttons. The former will display the modal dialog allowing the user to change the values. The latter will clear all the values set (including cookies if enabled).\n\n## Cookies\n\nIt is possible to save the user's parameter values across session by saving them to cookies (as long as `allow_cookies = TRUE`). If the `allow_cookies` parameter is `TRUE`, the user can still opt to not save the values as cookies. It is recommend to set the `cookie_password` value so that the cookie values are encrypted. This feature uses the [cookies](https://cookies.shinyworks.org) R package and requires that `cookies::cookie_dependency()` is place somewhere in the Shiny UI.\n\n## Full Shiny Demo\n\nThe figures above are from the Shiny application provided below.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(login)\nlibrary(cookies)\n\n#' Simple email validator.\n#' @param x string to test.\n#' @return TRUE if the string is a valid email address.\nis_valid_email <- function(x) {\n\tgrepl(\"\\\\<[A-Z0-9._%+-]+@[A-Z0-9.-]+\\\\.[A-Z]{2,}\\\\>\", as.character(x), ignore.case=TRUE)\n}\n\n#' Custom validator function that also checks if the `email` field is a valid email address.\nmy_validator <- function(values, types) {\n\tspv <- simple_parameter_validator(values)\n\tif(!is.logical(spv)) {\n\t\treturn(spv)\n\t} else {\n\t\tif(is_valid_email(values[['email']])) {\n\t\t\treturn(TRUE)\n\t\t} else {\n\t\t\treturn(paste0(values[['email']], ' is not a valid email address.'))\n\t\t}\n\t}\n\treturn(TRUE)\n}\n\nui <- shiny::fluidPage(\n\tcookies::cookie_dependency(),  # Necessary to save/get cookies\n\tshiny::titlePanel('Parameter Example'),\n\tshiny::verbatimTextOutput('param_values'),\n\tshowParamButton('example'),\n\tclearParamButton('example')\n)\n\nserver <- function(input, output) {\n\tparams <- userParamServer(\n\t\tid = 'example',\n\t\tvalidator = my_validator,\n\t\tparams = c('name', 'email'),\n\t\tparam_labels = c('Your Name:', 'Email Address:'),\n\t\tparam_types = c('character', 'character'),\n\t\tintro_message = 'This is an example application that asks the user for two parameters.')\n\n\toutput$param_values <- shiny::renderText({\n\t\ttxt <- character()\n\t\tfor(i in names(params)) {\n\t\t\ttxt <- paste0(txt, i, ' = ', params[[i]], '\\n')\n\t\t}\n\t\treturn(txt)\n\t})\n}\n\nshiny::shinyApp(ui = ui, server = server, options = list(port = 2112))\n```\n:::\n\n\n\n\n## Validation\n\nThe `validator` parameter speicies a validation function to ensure the parameters entered by the user are valid. The default value of `simple_parameter_validator()` simply ensures that values have been entered. The Shiny application above extends this by also checking to see if the email address appears to be valid. \n\nValidations functions must adhere to the following:\n\n1. It must take two parameters: `values` which is a character vector the user has entered and `types` which is a character vector of the types described above.\n\n2. Return `TRUE` if the validaiton passes OR a character string describing why the validation failed. This message will be displayed to the user.\n\nIf the validation function returns anything other than `TRUE` the modal dialog will be displayed. \n\n### Customizing the Shiny inputs\n\nThe `input_params` parameter allows for further customization of the various Shiny inputs. In particular, you can put any other `shiny::xxxInput` parameters into a list. For `select` input types the `choices` parameter is required. The following template provides the basic structure:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput_params = list(PARAM1 = list(choices = c('Option A', 'Option B')), # When select is the type\n\t\t\t\t\tPARAM2 = list(min = 0, max = 10, stap = 1)) # When numeric or integer is the type\n```\n:::\n\n\n\n\n## File Input Example\n\nThe following Shiny application demonstrates how to use the file upload and drop down selection features.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(login)\nlibrary(cookies)\n\n#' Custom validator function that also checks if the `file` field is a valid CSV file.\nmy_validator <- function(values, types) {\n\tspv <- simple_parameter_validator(values)\n\tif(!is.logical(spv)) {\n\t\treturn(spv)\n\t} else {\n\t\tif(!file.exists(values$file)) {\n\t\t\treturn('File does not exists. Try uploading again.')\n\t\t} else if(!tools::file_ext(values$file) %in% c('csv', 'xslx')) {\n\t\t\treturn('Only CSV and XLSX files supported.')\n\t\t}\n\t}\n\treturn(TRUE)\n}\n\nui <- shiny::fluidPage(\n\tcookies::cookie_dependency(),  # Necessary to save/get cookies\n\tshiny::titlePanel('Data Viewer'),\n\tshowParamButton('csvviewer'),\n\tclearParamButton('csvviewer'),\n\tDT::DTOutput('data_table')\n)\n\nserver <- function(input, output) {\n\tparams <- userParamServer(\n\t\tid = 'csvviewer',\n\t\tvalidator = my_validator,\n\t\tparams = c('filetype', 'file'),\n\t\tparam_labels = c('File type', 'URL to a CSV file:'),\n\t\tinput_params = list(\"filetype\" = list(\"choices\" = c(\"\", \"CSV\" = \"csv\", \"Excel\" = \"xlsx\"))),\n\t\tparam_types = c('select', 'file'),\n\t\tintro_message = 'This application will view a spreadsheet as a data table.')\n\n\toutput$data_table <- DT::renderDT({\n\t\tdf <- data.frame()\n\t\tif(file.exists(params$file)) {\n\t\t\tif(params$filetype == 'csv') {\n\t\t\t\tdf <- read.csv(params$file)\n\t\t\t} else if(params$filetype == 'xlsx') {\n\t\t\t\tdf <- readxl::read_excel(params$file)\n\t\t\t}\n\t\t}\n\t\treturn(df)\n\t})\n}\n\nshiny::shinyApp(ui = ui, server = server, options = list(port = 2112))\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
{
  "hash": "2fc2fbe0ad747adbbaf2d4f30c85c31a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"How many times do I need to take a test to randomly get all questions correct?\"\nauthor: \"Jason Bryer\"\ndate: 2025-02-06\ndraft: false\ndescription: \"\"\ncategories: [\"R\", \"Statistics\"]\nimage: \"2025-02-06-Waiting_to_pass_exam.png\"\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell}\n\n:::\n\n[Darrin Rogers asked on Mastadon](https://fediscience.org/@DarrinLRogers/113952951823744486) what are the \"number of tries it would take, guessing randomly, to get 100% on a quiz if you had unlimited retries.\" Here we will outline two ways to solve this problem: using a simulation and using a combination of the binomial and geometric distributions. Let's consider an example of a 5 question test where each question has four options, hence the probability of getting any one question correct is 1/4.\n\n::: {.cell}\n\n```{.r .cell-code}\nsize <- 5 # Test size (i.e. number of questions)\np <- 1/4 # Probability of randomly getting correct answer\n```\n:::\n\nWe can use the `sample` function to simulate on test attempt.\n\n::: {.cell}\n\n```{.r .cell-code}\ntest <- sample(c(TRUE, FALSE), size = size, prob = c(p, 1 - p), replace = TRUE)\ntest\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\nNext, let's write a function that will simulate repeatedly take a test until all the questions are correct. I have added an additional parameter `stop_score` which specifies the mean score on the test before stopping. This will allow us to modify the question to answer how many tests do I need to take to pass. For now, `stop_score = 1` will continue until all questions are correct.\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Simulate how long until a specified number of responses are correct\n#' @param size test size.\n#' @param prob probability of randomly getting correct answer\n#' @param stop_score the score on the test we wish to achieve. Value of 1\n#'        indicates a perfect score.\nsimulate_test <- function(size, p, stop_score = 1) {\n\tn <- 0\n\trepeat{\n\t\tn <- n + 1\n\t\ttest <- sample(c(TRUE, FALSE),\n\t\t\t\t\t   size = size,\n\t\t\t\t\t   prob = c(p, 1 - p),\n\t\t\t\t\t   replace = TRUE)\n\t\tif(mean(test) >= stop_score) {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn(n)\n}\n```\n:::\n\nWe can run one test to see how long we need to wait until all questions on the test were answered correctly.\n\n::: {.cell}\n\n```{.r .cell-code}\n(num_tests <- simulate_test(size = size, p = p))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 158\n```\n\n\n:::\n:::\n\nFor this one simulation, it took 158 to randomly get all the questions correct. Let's now run this simulation 1,000 times.\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulations <- integer(1000)\nfor(i in 1:length(simulations)) {\n\tsimulations[i] <- simulate_test(size = size, p = p)\n}\nmean(simulations)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 977.858\n```\n\n\n:::\n\n```{.r .cell-code}\nmedian(simulations)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 687\n```\n\n\n:::\n:::\n\nFor this simulation the average \"wait time\" until all questions were answered correctly is 977.858. Since the distribution is not symmetrical it may be more appropriate to use the median. Here, 50% of the simulations returned a perfect score in fewer than 687 attempts.\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data.frame(x = simulations), aes(x = x)) +\n\tgeom_histogram(aes(y = ..density..), bins = 50, fill = 'grey70') +\n\tgeom_density(color = 'blue') +\n\tggtitle('Distribution of simulation results')\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The dot-dot notation (`..density..`) was deprecated in ggplot2 3.4.0.\nâ„¹ Please use `after_stat(density)` instead.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](2025-02-06-Waiting_to_pass_exam_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\nLet's return to a single test attempt. We can use the binomial distribution to calculate the probability of getting *k* questions correct on this 5 question test.\n\n::: {.cell}\n\n```{.r .cell-code}\ndist <- dbinom(x = 0:size, size = size, prob = p)\nggplot(data.frame(x = 0:size,\t\t\t\t\t\t   \n\t\t\t\t  prob = dist,\n\t\t\t\t  label = paste0(round(100 * dist, digits = 2), '%')),\n\t   aes(x = x, y = prob, label = label)) +\n\tgeom_bar(stat = 'identity', fill = 'grey50') +\n\tgeom_text(vjust = -0.5)\n```\n\n::: {.cell-output-display}\n![](2025-02-06-Waiting_to_pass_exam_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\nThe probability of getting all 5 questions on this test is 9.765625\\times 10^{-4}. We can now treat each test attempt as a [Bernoulli trial](https://en.wikipedia.org/wiki/Bernoulli_trial) where the probability of success is 9.765625\\times 10^{-4}. The [geometric distribution](https://en.wikipedia.org/wiki/Geometric_distribution) gives us the number of Bernoulli trials we need to get one success. The mean for the geometric distribution are:\n\n$$ \\mu = \\frac{1}{p} $$\n\nTherefore, it will take an average of 1024 test attempts before getting all questions correct on the attempt.\n\n::: {.cell}\n\n```{.r .cell-code}\n(p_all_correct <- dbinom(x = size, size = size, prob = p))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.0009765625\n```\n\n\n:::\n\n```{.r .cell-code}\n1 / p_all_correct\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1024\n```\n\n\n:::\n:::\n\nHowever, the geometric distribution is not symmetrical so using the mean not be desirable. Here is the geometric distribution for where the probability of success is 9.765625\\times 10^{-4}.\n\n::: {.cell}\n\n```{.r .cell-code}\ngeom_dist <- data.frame(x = 0:5000,\n\t\t\t\t\t\ty = dgeom(0:5000, prob = dbinom(x = size, size = size, prob = p)))\ncut_point50 <- qgeom(0.50, prob = dbinom(x = size, size = size, prob = p))\ncut_point95 <- qgeom(0.95, prob = dbinom(x = size, size = size, prob = p))\nggplot(geom_dist, aes(x = x, y = y)) +\n\tgeom_polygon(data = rbind(data.frame(x = 0, y = 0),\n\t\t\t\t\t\t\t  geom_dist[geom_dist$x < cut_point95,],\n\t\t\t\t\t\t\t  data.frame(x = cut_point95, y = 0)),\n\t\t\t\t fill = 'grey70') +\n\tgeom_polygon(data = rbind(data.frame(x = 0, y = 0),\n\t\t\t\t\t\t\t  geom_dist[geom_dist$x < cut_point50,],\n\t\t\t\t\t\t\t  data.frame(x = cut_point50, y = 0)),\n\t\t\t\t fill = 'grey50') +\n\tgeom_path(stat = 'identity', color = 'blue')\n```\n\n::: {.cell-output-display}\n![](2025-02-06-Waiting_to_pass_exam_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\nThe shaded area corresponds to 50% of the area. That is, if we conduct 709 tests we are 50% likely to get a test with all the answers correct. Want to be 95% sure to get a test with all answers correct, then administer 3066 tests.\n\nWe can tweak the question slightly: What is the average number of tests I would have to take before passing if the answers are randomly selected? For this example, I am considering getting 4 or 5 questions correct passing. We can get the probability of getting 4 or 5 questions correct from the binomial distribution, which is 0.015625.\n\n::: {.cell}\n\n```{.r .cell-code}\np_pass <- dbinom(x = 4:5, size = size, prob = p) |> sum()\n1 / p_pass\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 64\n```\n\n\n:::\n:::\n\nTo just pass, we have to wait much less. We can also calculate this using the `simulate_test` function defined above. \n\n::: {.cell}\n\n```{.r .cell-code}\nsimulations2 <- integer(1000)\nfor(i in 1:length(simulations2)) {\n\tsimulations2[i] <- simulate_test(size = size, p = p, stop_score = 0.8)\n}\nmean(simulations2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 62.291\n```\n\n\n:::\n\n```{.r .cell-code}\nmedian(simulations2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 44\n```\n\n\n:::\n:::\n\nOr using the geometric distribution:\n\n::: {.cell}\n\n```{.r .cell-code}\nqgeom(0.50, prob = p_pass)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 44\n```\n\n\n:::\n\n```{.r .cell-code}\nqgeom(0.95, prob = p_pass)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 190\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
{
  "hash": "33069fda82bb6c65b911ebee25fe89ea",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Bootstrap vs Standard Error Confidence Intervals\"\nauthor: \"Jason Bryer\"\ndate: 2025-03-12\ndraft: false\ndescription: \"\"\ncategories: [\"R\", \"Statistics\"]\nimage: \"2025-03-12-Bootstrap_vs_Standard_Error.png\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nA student recently asked whether bootstrap confidence intervals were more robust than confidence intervals estimated using the standard error (i.e. $SE = \\frac{s}{\\sqrt{n}}$). In order to answer this question I wrote a function to simulate taking a bunch of random samples from a population, calculate the confidence interval for that sample using the standard error approach (the *t* distribution is used by default, see the `cv` parameter. To use the normal distribution, for example, set `cv = 1.96`.), and then also calculating a confidence interval using the boostrap.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(ggplot2)\n\n#' Simulate random samples to estimate confidence intervals and bootstrap\n#' estimates.\n#'\n#' @param pop a numeric vector representing the population.\n#' @param n sample size for each random sample from the population.\n#' @param n_samples the number of random samples.\n#' @param n_boot number of bootstrap samples to take for each sample.\n#' @param seed a seed to use for the random process.\n#' @param cv critical value to use for calculating confidence intervals.\n#' @return a data.frame with the sample and bootstrap mean and confidence\n#'        intervals along with a logical variable indicating whether a Type I\n#'        error would have occurred with that sample.\nbootstrap_clt_simulation <- function(\n\t\tpop,\n\t\tn = 30,\n\t\tn_samples = 500,\n\t\tn_boot = 500,\n\t\tcv = abs(qt(0.025, df = n - 1)),\n\t\tseed,\n\t\tverbose = interactive()\n) {\n\tif(missing(seed)) {\n\t\tseed <- sample(100000)\n\t}\n\tresults <- data.frame(\n\t\tseed = 1:n_samples,\n\t\tsamp_mean = numeric(n_samples),\n\t\tsamp_se = numeric(n_samples),\n\t\tsamp_ci_low = numeric(n_samples),\n\t\tsamp_ci_high = numeric(n_samples),\n\t\tsamp_type1 = logical(n_samples),\n\t\tboot_mean = numeric(n_samples),\n\t\tboot_ci_low = numeric(n_samples),\n\t\tboot_ci_high = numeric(n_samples),\n\t\tboot_type1 = logical(n_samples)\n\t)\n\tif(verbose) {\n\t\tpb <- txtProgressBar(min = 0, max = n_samples, style = 3)\n\t}\n\tfor(i in 1:n_samples) {\n\t\tif(verbose) {\n\t\t\tsetTxtProgressBar(pb, i)\n\t\t}\n\t\tset.seed(seed + i)\n\t\tsamp <- sample(pop, size = n)\n\t\tboot_samp <- numeric(n_boot)\n\t\tfor(j in 1:n_boot) {\n\t\t\tboot_samp[j] <- sample(samp, size = length(samp), replace = TRUE) |>\n\t\t\t\tmean()\n\t\t}\n\t\tresults[i,]$seed <- seed + i\n\t\tresults[i,]$samp_mean <- mean(samp)\n\t\tresults[i,]$samp_se <- sd(samp) / sqrt(length(samp))\n\t\tresults[i,]$samp_ci_low <- mean(samp) - cv * results[i,]$samp_se\n\t\tresults[i,]$samp_ci_high <- mean(samp) + cv * results[i,]$samp_se\n\t\tresults[i,]$samp_type1 <- results[i,]$samp_ci_low > mean(pop) |\n\t\t\tmean(pop) > results[i,]$samp_ci_high\n\t\tresults[i,]$boot_mean <- mean(boot_samp)\n\t\tresults[i,]$boot_ci_low <- mean(boot_samp) - cv * sd(boot_samp)\n\t\tresults[i,]$boot_ci_high <- mean(boot_samp) + cv * sd(boot_samp)\n\t\tresults[i,]$boot_type1 <- results[i,]$boot_ci_low > mean(pop) |\n\t\t\tmean(pop) > results[i,]$boot_ci_high\n\t}\n\tif(verbose) {\n\t\tclose(pb)\n\t}\n\treturn(results)\n}\n```\n:::\n\n\n\n\n**Uniform distribution for the population**\n\nLet's start with a uniform distribution for our population.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop_unif <- runif(1e5, 0, 1)\nggplot(data.frame(x = pop_unif), aes(x = x)) + geom_density()\n```\n\n::: {.cell-output-display}\n![](2025-03-23-Bootstrap_vs_Standard_Error_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n\nThe mean of the population is 0.5008915. We can now simulate samples and their corresponding bootstrap estimates.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults_unif <- bootstrap_clt_simulation(pop = pop_unif, seed = 42, verbose = FALSE)\n```\n:::\n\n\n\n\n5.8% of our samples did not contain the population mean in the confidence interval (i.e. Type I error rate) compared to `r `mean(results_unif$boot_type1) * 100`% of the bootstrap estimates. The following table compares the Type I errors for each sample compared to the bootstrap estiamted from that sample.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntab <- table(results_unif$samp_type1, results_unif$boot_type1, useNA = 'ifany')\ntab\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       \n        FALSE TRUE\n  FALSE   470    1\n  TRUE      1   28\n```\n\n\n:::\n:::\n\n\n\n\nIn general committing a type I error is the same regardless of method, though there were 1 instances where the bootstrap would have led to a type I error rate where the standard error approach would not.\n\nThe following plots show the relationship between the estimated mean (left) and condifence interval width (right) for each sample and its corresponding bootstrap.\n\n\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nresults_unif |>\n\tggplot(aes(x = samp_mean, y = boot_mean)) +\n\tgeom_vline(xintercept = mean(pop_unif), color = 'blue') +\n\tgeom_hline(yintercept = mean(pop_unif), color = 'blue') +\n\tgeom_abline() +\n\tgeom_point() +\n\tggtitle(\"Sample mean vs bootstrap mean\")\n```\n\n::: {.cell-output-display}\n![](2025-03-23-Bootstrap_vs_Standard_Error_files/figure-html/unnamed-chunk-6-1.png){width=100%}\n:::\n\n```{.r .cell-code}\nresults_unif |>\n\tdplyr::mutate(samp_ci_width = samp_ci_high - samp_ci_low,\n\t\t\t\t  boot_ci_width = boot_ci_high - boot_ci_low) |>\n\tggplot(aes(x = samp_ci_width, y = boot_ci_width)) +\n\tgeom_abline() +\n\tgeom_point() +\n\tggtitle('Sample vs boostrap confidence interval width')\n```\n\n::: {.cell-output-display}\n![](2025-03-23-Bootstrap_vs_Standard_Error_files/figure-html/unnamed-chunk-6-2.png){width=100%}\n:::\n:::\n\n\n\n\n**Skewed distribution for the population**\n\nWe will repeat the same analysis using a positively skewed distribution.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop_skewed <- rnbinom(1e5, 3, .5)\nggplot(data.frame(x = pop_skewed), aes(x = x)) + geom_density(bw = 0.75)\n```\n\n::: {.cell-output-display}\n![](2025-03-23-Bootstrap_vs_Standard_Error_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n\nThe mean of the population for this distribution is 2.99792\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults_skewed <- bootstrap_clt_simulation(pop = pop_skewed, seed = 42, verbose = FALSE)\nmean(results_skewed$samp_type1) # Percent of samples with Type I error\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.05\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(results_skewed$boot_type1) # Percent of bootstrap estimates with Type I error\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.052\n```\n\n\n:::\n\n```{.r .cell-code}\n# CLT vs Bootstrap Type I error rate\ntable(results_skewed$samp_type1, results_skewed$boot_type1, useNA = 'ifany')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       \n        FALSE TRUE\n  FALSE   473    2\n  TRUE      1   24\n```\n\n\n:::\n:::\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nresults_skewed |>\n\tggplot(aes(x = samp_mean, y = boot_mean)) +\n\tgeom_vline(xintercept = mean(pop_skewed), color = 'blue') +\n\tgeom_hline(yintercept = mean(pop_skewed), color = 'blue') +\n\tgeom_abline() +\n\tgeom_point() +\n\tggtitle(\"Sample mean vs bootstrap mean\")\n```\n\n::: {.cell-output-display}\n![](2025-03-23-Bootstrap_vs_Standard_Error_files/figure-html/unnamed-chunk-9-1.png){width=100%}\n:::\n\n```{.r .cell-code}\nresults_skewed |>\n\tdplyr::mutate(samp_ci_width = samp_ci_high - samp_ci_low,\n\t\t\t\t  boot_ci_width = boot_ci_high - boot_ci_low) |>\n\tggplot(aes(x = samp_ci_width, y = boot_ci_width)) +\n\tgeom_abline() +\n\tgeom_point() +\n\tggtitle('Sample vs boostrap confidence interval width')\n```\n\n::: {.cell-output-display}\n![](2025-03-23-Bootstrap_vs_Standard_Error_files/figure-html/unnamed-chunk-9-2.png){width=100%}\n:::\n:::\n\n\n\n\nWe can see the results are very similar to that of the uniform distirubtion. Exploring the one case where the bootstrap would have resulted in a Type I error where the standard error approach would not reveals that it is very close with the difference being less than 0.1.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults_differ <- results_skewed |>\n\tdplyr::filter(!samp_type1 & boot_type1)\nresults_differ\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  seed samp_mean   samp_se samp_ci_low samp_ci_high samp_type1 boot_mean\n1  443  3.866667 0.4516466    2.942946     4.790388      FALSE  3.924733\n2  474  3.933333 0.4816956    2.948155     4.918511      FALSE  3.956800\n  boot_ci_low boot_ci_high boot_type1\n1    3.044802     4.804665       TRUE\n2    3.018549     4.895051       TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(results_differ[1,]$seed)\nsamp <- sample(pop_skewed, size = 30)\nboot_samp <- numeric(500)\nfor(j in 1:500) {\n\tboot_samp[j] <- sample(samp, size = length(samp), replace = TRUE) |>\n\t\tmean()\n}\ncv = abs(qt(0.025, df = 30 - 1))\nmean(pop_skewed)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.99792\n```\n\n\n:::\n\n```{.r .cell-code}\nci <- c(mean(samp) - cv * sd(samp) / sqrt(30), mean(samp) + cv * sd(samp) / sqrt(30))\nci\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.942946 4.790388\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(pop_skewed) < ci[1] | mean(pop_skewed) > ci[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nci_boot <- c(mean(boot_samp) - cv * sd(boot_samp), mean(boot_samp) + cv * sd(boot_samp))\nci_boot\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.044802 4.804665\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(pop_skewed) < ci_boot[1] | mean(pop_skewed) > ci_boot[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n### Adding an outlier\n\nLet's consider a sample that forces the largest value from the population to be in the sample.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2112)\nsamp_outlier <- c(sample(pop_skewed, size = 29), max(pop_skewed))\nboot_samp <- numeric(500)\nfor(j in 1:500) {\n\tboot_samp[j] <- sample(samp, size = length(samp), replace = TRUE) |>\n\t\tmean()\n}\n\nci <- c(mean(samp_outlier) - cv * sd(samp_outlier) / sqrt(30), mean(samp_outlier) + cv * sd(samp_outlier) / sqrt(30))\nci\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.647006 4.952994\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(pop_skewed) < ci[1] | mean(pop_skewed) > ci[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nci_boot <- c(mean(boot_samp) - cv * sd(boot_samp), mean(boot_samp) + cv * sd(boot_samp))\nci_boot\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.905153 4.781381\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(pop_skewed) < ci_boot[1] | mean(pop_skewed) > ci_boot[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\nIn this example we do see that the presense of the outlier does have a bigger impact on the confidence interval with the bootstrap confidence interval being much smaller.\n\n### Sample and bootstrap size related to standard error\n\nLet's also explore the relationship of *n*, number of bootstrap samples, and standard error. Recall the formula for the standard error is:\n\n$$ SE = \\frac{\\sigma}{\\sqrt{n}} $$\n\nThe figure below plots the standard error against the standard error assuming sigma (standard deviation) is one. As you can see, simply increasing the sample size will decrease the standard error (and therefore the confidence interval).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nse <- function(n, sigma = 1) {\n\tsigma / sqrt(n)\n}\nggplot() + stat_function(fun = se) + xlim(c(0, 100)) +\n\tylab('Standard Error') + xlab('Sample Size (n)')\n```\n\n::: {.cell-output-display}\n![](2025-03-23-Bootstrap_vs_Standard_Error_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n\nConsidering again a population with a uniform distribution, the following code will draw random samples with *n* ranging from 30 to 50 in increments of 15. For each of those random samples, we will also estimate boostrap standard errors with the number of bootstrap samples ranging from 50 to 1,000 in increments of 50.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- seq(30, 500, by = 15)\nn_boots <- seq(50, 1000, by = 50)\n\nresults <- expand.grid(n, n_boots)\nattributes(results) <- NULL\nresults <- as.data.frame(results)\nnames(results) <- c('n', 'n_boots')\nresults$samp_mean <- NA\nresults$samp_se <- NA\nresults$boot_mean <- NA\nresults$boot_se <- NA\n\nfor(i in seq_len(nrow(results))) {\n\tsamp <- sample(pop_unif, size = results[i,]$n)\n\tresults[i,]$samp_mean <- mean(samp)\n\tresults[i,]$samp_se <- sd(samp) / sqrt(length(samp))\n\tboot_samp_dist <- numeric(results[i,]$n_boots)\n\tfor(j in seq_len(results[i,]$n_boots)) {\n\t\tboot_samp_dist[j] <- sample(samp, size = length(samp), replace = TRUE) |> mean()\n\t}\n\tresults[i,]$boot_mean <- mean(boot_samp_dist)\n\tresults[i,]$boot_se <- sd(boot_samp_dist)\n}\n```\n:::\n\n\n\n\nThe figure to the left plots the sample size against the standard error which, like above, shows that as the sample size increases the standard error decreases. On the right is a plot of the number of bootstrap samples against the standard error where the point colors correspond to the sample size. Here we see the standard error is constant. That is, the number of bootstrap samples is not related to the standard error. The variability in standard error is accounted for by the sample size.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny_limits <- c(0, 0.075)\np_samp_size_se <- ggplot(results, aes(x = n, y = samp_se)) + \n\tgeom_point(fill = '#9ecae1', color = 'grey50', shape = 21) + \n\tgeom_smooth(color = 'darkgreen', se = FALSE, method = 'loess', formula = y ~ x) +\n\tylim(y_limits) +\n\tylab('Standard Error') +\n\txlab('Sample size (n)') +\n\tggtitle(latex2exp::TeX(\"Standard Error (SE = \\\\frac{\\\\sigma}{\\\\sqrt{n}})\")) +\n\tscale_fill_gradient(low = '#deebf7', high = '#3182bd') +\n\ttheme(legend.position = 'bottom')\n\np_boot_size_se <- \n\tggplot(results, aes(x = n_boots, y = boot_se)) + \n\tgeom_point(aes(fill = n), color = 'grey50', shape = 21) +\n\tgeom_smooth(color = 'darkgreen', se = FALSE, method = 'loess', formula = y ~ x) +\n\tylim(y_limits) +\n\tylab('Standard Error') +\n\txlab('Number of Bootstrap Samples') +\n\tggtitle('Bootstrap Standard Error',\n\t\t\tsubtitle = '(i.e. standard deviation of the bootstrap sample)') +\n\tscale_fill_gradient(low = '#deebf7', high = '#3182bd') #+ theme(legend.position = 'none')\n\ncowplot::plot_grid(p_samp_size_se, p_boot_size_se)\n```\n\n::: {.cell-output-display}\n![](2025-03-23-Bootstrap_vs_Standard_Error_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n\nLastly we can plot the relationship between the two standard error estimates; the correlation of which is extremely high with r = 0.99.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(results, aes(x = samp_se, y = boot_se)) +\n\tgeom_abline() +\n\tgeom_point() +\n\txlab('Sample Standard Error') +\n\tylab('Boostrap Standard Error') +\n\tggtitle(paste0('Correlation between standard errors = ', round(cor(results$samp_se, results$boot_se), digits = 2))) +\n\tcoord_equal()\n```\n\n::: {.cell-output-display}\n![](2025-03-23-Bootstrap_vs_Standard_Error_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
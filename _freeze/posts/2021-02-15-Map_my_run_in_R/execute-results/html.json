{
  "hash": "efcb86d87dae5e4e03e7283860a3af20",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Map my run in R\"\nauthor: \"Jason Bryer\"\ndate: 2021-02-15\ndraft: false\ndescription: \"\"\ncategories: [\"R\"]\nimage: \"2021-02-15-Map_my_run_in_R.png\"\neditor_options: \n  chunk_output_type: console\n---\n\nFirst, I want to give a plug to the [RStats Strava Running Club](https://www.strava.com/clubs/rstats). If you are into running, it is a great group that provides lots of support.\n\nThis post is inspired by [this streetmaps](https://ggplot2tutor.com/streetmaps/streetmaps/) tutorial over at [ggplot2tutor.com](https://ggplot2tutor.com) on creating map artwork/posters. This post shows how to overlay running (which could be biking) routes.\n\nThe key for this to work is to get access to [GPX](https://en.wikipedia.org/wiki/GPS_Exchange_Format) (GPS Exchange format) files. I use an Apple watch to track my runs and the [HealthFit App](https://apps.apple.com/bf/app/healthfit/id1202650514) to sync my runs to [Strava](https://www.strava.com/clubs/rstats) and Dropbox (note there are a lot of export options) where it will upload GPX files. For this post, I extracted two GPX files for when I ran the NYC Marathon in 2019 and the Disney Marathon in 2020.\n\nTo begin, I load the necessary R packages and define some variables so that the script can easily be modified for other maps. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(osmdata)\nlibrary(tmaptools)\nlibrary(XML)\nlibrary(ggplot2)\n\npalette.nyc <- c(\n\tbackground = '#0850A4',\n\twater = '#0850A4',\n\tstreets = '#3D88C7',\n\tsmall_streets = '#3D88C7',\n\trivers = '#0850A4',\n\troute = '#1B295A',\n\tlabels = '#3D88C7',\n\ttitle = '#A8BACA'\n)\n\ngpx.file <- '2019-11-03-NYC-Marathon.gpx'\npalette <- palette.nyc\ntitle <- 'NYC Marathon'\nsubtitle <- 'November 3, 2009'\ntitle.hjust <- 0 # 0 = left align; 1 = right aling\ndistance <- \"mi\" # Distance unit, one of: \"m\", \"km\", \"mi\", and \"ft\"\n```\n:::\n\n\n\nThe following R code reads in the GPX file (which is an XML file) and converts it to a matrix of longitude and latitude coordinates. The `bb` variable defines the minimum bounding rectangle that encompasses the entire route. This will define the bounds of the street data we will download.\n\n::: {.cell}\n\n```{.r .cell-code}\ngpx <- XML::htmlTreeParse(gpx.file, \n\t\t\t\t\t error = function (...) {}, useInternalNodes = T)\n\ncoords <- xpathSApply(gpx, path = \"//trkpt\", xmlAttrs)\nlats <- as.numeric(coords[\"lat\",])\nlons <- as.numeric(coords[\"lon\",])\npath <- data.frame(x = lons, y = lats)\nbb <- matrix(c(min(path$x), min(path$y), max(path$x), max(path$y)),\n\t\t\t nrow = 2, ncol = 2,\n\t\t\t dimnames = list(c('x','y'), c('min', 'max')))\nbb\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        min       max\nx -74.06163 -73.92439\ny  40.60176  40.81475\n```\n\n\n:::\n:::\n\nThe next chunk calculates the distance between each coordinate and the cumulative sum/distance. Note that this is an inefficient chunk since I used a for loop to calculate the distances.\n\n::: {.cell}\n\n```{.r .cell-code}\npath$distance <- 0\nfor(i in 2:nrow(path)) { \n\t# Probably shouldn't use a loop, this is slow. Not sure what to use instead.\n\tpath[i,]$distance <- as.numeric(\n\t\tapprox_distances(unlist(path[i - 1,,drop=TRUE]), unlist(path[i,,drop=TRUE]), \n\t\t\t\t\t\t target = distance, projection = 4326)\n\t)\n}\npath$cum_distance <- cumsum(path$distance)\n```\n:::\n\nNext, we create a separate data frame for the mile markers. We could round up or down here. For NYC, my watch registered just under 26 miles so to ensure a 26 mile marker is shown, we will round up here. I presume the GPS lost accuracy when running on the lower level of bridges and/or through the buildings.\n\n::: {.cell}\n\n```{.r .cell-code}\n# markers <- path[!duplicated(floor(path$cum_distance)),][-1,]\nmarkers <- path[!duplicated(ceiling(path$cum_distance), fromLast = TRUE),][-1,]\n```\n:::\n\n\nThe next block of R code (which is largely copied from the ggplot2tutor tutorial) downloads map data from OpenStreet Map.\n\n::: {.cell}\n\n```{.r .cell-code}\nstreets <- bb %>%\n\topq() %>%\n\tadd_osm_feature(key = \"highway\", \n\t\t\t\t\tvalue = c(\"motorway\", \"primary\", \"trunk\",\n\t\t\t\t\t\t\t  \"secondary\", \"tertiary\")) %>%\n\tosmdata_sf()\n\nsmall_streets <- bb %>%\n\topq() %>%\n\tadd_osm_feature(key = \"highway\",\n\t\t\t\t\tvalue = c(\"residential\", \"living_street\",\n\t\t\t\t\t\t\t  \"unclassified\",\n\t\t\t\t\t\t\t  \"service\", \"footway\")) %>%\n\tosmdata_sf()\n\nriver <- bb %>%\n\topq() %>%\n\tadd_osm_feature(key = \"waterway\", value = \"river\") %>%\n\tosmdata_sf()\n\nwater <- bb %>%\n\topq() %>%\n\tadd_osm_feature(key = \"natural\", value = c('water')) %>%\n\tosmdata_sf()\n```\n:::\n\nNow that the data is downloaded, we can begin building the map using `ggplot2`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap <- ggplot() +\n\tgeom_sf(data = water$osm_multipolygons,\n\t\t\tinherit.aes = FALSE,\n\t\t\tfill = palette['water'],\n\t\t\tcolor = NA,\n\t\t\talpha = .3) +\n\tgeom_sf(data = streets$osm_lines,\n\t\t\tinherit.aes = FALSE,\n\t\t\tcolor = palette['streets'],\n\t\t\tsize = .3,\n\t\t\talpha = .6) +\n\tgeom_sf(data = small_streets$osm_lines,\n\t\t\tinherit.aes = FALSE,\n\t\t\tcolor = palette['small_streets'],\n\t\t\tsize = .1,\n\t\t\talpha = .5) +\n\tgeom_sf(data = river$osm_lines,\n\t\t\tinherit.aes = FALSE,\n\t\t\tcolor = palette['rivers'],\n\t\t\tsize = .2,\n\t\t\talpha = .3) +\n\tgeom_path(data = path, aes(x = x, y = y),\n\t\t\t  color = palette['route'],\n\t\t\t  size = 1) +\n\tgeom_point(data = markers, aes(x = x, y = y),\n\t\t\t   inherit.aes = FALSE,\n\t\t\t   color = palette['labels'],\n\t\t\t   fill = palette['route'],\n\t\t\t   shape = 21, stroke = 1, size = 5) +\n\tgeom_point(data = path[1,], aes(x = x, y = y),\n\t\t\t   inherit.aes = FALSE,\n\t\t\t   color = palette['labels'],\n\t\t\t   fill = 'green',\n\t\t\t   shape = 21, stroke = 1, size = 5) +\n\tgeom_point(data = path[nrow(path),], aes(x = x, y = y),\n\t\t\t   inherit.aes = FALSE,\n\t\t\t   color = palette['labels'],\n\t\t\t   fill = 'red',\n\t\t\t   shape = 21, stroke = 1, size = 5) +\n\tgeom_text(data = markers, aes(x = x, y = y, label = ceiling(cum_distance)),\n\t\t\t  inherit.aes = FALSE,\n\t\t\t  color = palette['labels'],\n\t\t\t  size = 2) +\n\tcoord_sf(xlim = bb[1,],\n\t\t\t ylim = bb[2,]) +\n\ttheme_void() +\n\ttheme(plot.background = element_rect(fill = palette['background']))\n```\n:::\n\n\nThe last modifies the them and adds a title. For the poster I printed, I excluded the title and instead added the marathon logo in Photoshop.\n\n::: {.cell}\n\n```{.r .cell-code}\nmap + ggtitle(title,   \n\t\t\t  subtitle = subtitle) +\n\ttheme(panel.background = element_rect(fill = palette['background'], color = palette['background']),\n\t\t  panel.spacing = margin(0,0,0,0),\n\t\t  plot.margin = margin(-45,10,10,10),\n\t\t  plot.title = element_text(color = palette['title'],\n\t\t  \t\t\t\t\t\t  size = 20,\n\t\t  \t\t\t\t\t\t  hjust = title.hjust, vjust = -10,\n\t\t  \t\t\t\t\t\t  family = 'Helvetica'),\n\t\t  plot.subtitle = element_text(color = palette['title'],\n\t\t  \t\t\t\t\t\t\t size = 16,\n\t\t  \t\t\t\t\t\t\t hjust = title.hjust, vjust = -12,\n\t\t  \t\t\t\t\t\t\t family = 'Helvetica'))\n```\n\n::: {.cell-output-display}\n![](2021-02-15-Map_my_run_in_R_files/figure-html/unnamed-chunk-7-1.png){width=576}\n:::\n:::\n\nThe `ggsave` will save the map to a file.\n\n::: {.cell}\n\n```{.r .cell-code}\nggsave(filename = paste0(gsub(' ', '_', title), '.png'), width = 8)\n```\n:::\n\n\n\nWith a few modifications to the variables set above, we can easily create another map for another race.\n\n::: {.cell}\n\n```{.r .cell-code}\npalette.disney <- c(\n\tbackground = '#2775AE',\n\twater = '#92C0E6',\n\tstreets = '#1A365D',\n\tsmall_streets = '#1A365D',\n\trivers = '#92C0E6',\n\troute = '#E6A356',\n\tlabels = '#1A365D',\n\ttitle = '#1A365D'\n)\n\ngpx.file <- '2020-01-12-Disney-Marathon.gpx'\npalette <- palette.disney\ntitle <- 'Walt Disney World Marathon'\nsubtitle <- 'January 12, 2020'\ntitle.hjust <- 1 # 0 = left align; 1 = right aling\ndistance <- \"mi\" # Distance unit, one of: \"m\", \"km\", \"mi\", and \"ft\"\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](2021-02-15-Map_my_run_in_R_files/figure-html/unnamed-chunk-11-1.png){width=576}\n:::\n:::\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}